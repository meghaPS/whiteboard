const pathlib = require('path');
const fs = require('fs');
const schemaconf = require('schemaconf');
const { autogenerateDeckFromDir } = require('./utils');
const packageJson = require('../package.json');

let _store = null;
function _getStore() {
    if (_store === null) {
        /* eslint-disable global-require */
        const Store = require('electron-store');
        /* eslint-enable global-require */
        _store = new Store({
            defaults: {
                recent: [],
            },
        });
    }
    return _store;
}

function updateRecentList(filepath) {
    const store = _getStore();
    const recent = store.get('recent');
    const index = recent.indexOf(filepath);
    if (index !== -1) {
        recent.splice(index, 1);
    }
    recent.unshift({ path: filepath });
    store.set('recent', recent);
}

function saveToFile(filepath, data, callback) {
    const string = schemaconf.format.stringify(data);
    fs.writeFile(filepath, string, (err) => {
        if (err) {
            console.error('cannot write to path: ', filepath);
            throw err;
        }
        updateRecentList(filepath);
        callback();
    });
}

module.exports = {
    get_recent_list() {
        // TODO: clean this up, move it to Start, make it fault tolerant, and
        // async, and have it do it on ready
        const store = _getStore();
        const list = store.get('recent');
        return list.map(({ path }) => {
            // otherwise read data from file
            try {
                const contents = fs.readFileSync(path, 'utf-8');
                const data = schemaconf.format.parse(contents);
                return { path, data };
            } catch (e) {
                return { path };
            }
        });
    },

    loadDeck(manager, defaultPath, callback) {
        const { dialog } = manager.electron;
        dialog.showOpenDialog({
            defaultPath,
            properties: ['openFile'],
            filters: [
                { name: 'Whiteboard', extensions: ['whiteboard'] },
            ],
        }, (paths) => {
            if (!paths) {
                return; // canceled
            }

            if (defaultPath === paths[0]) {
                return; // don't do anything if we are re-opening same file
            }

            updateRecentList(paths[0]);
            // Otherwise, create a new window opening this thing
            manager.createWindow(paths[0], callback);
        });
    },

    import_directory(manager, defaultPath, callback) {
        const { dialog } = manager.electron;
        dialog.showOpenDialog({
            defaultPath,
            properties: ['openDirectory'],
        }, (paths) => {
            if (!paths) {
                return; // canceled
            }

            // Otherwise, create a new window opening this thing
            const slides = autogenerateDeckFromDir(paths[0]);
            if (slides && slides.length > 0) {
                const filepath = pathlib.resolve(paths[0], 'deck.whiteboard');
                const data = { slide: slides };
                saveToFile(filepath, data, () => {
                    console.log('SAVED TO ', filepath);
                    manager.createWindow(filepath, callback);
                });
            }
        });
    },

    newDeck(manager, defaultPath, callback) {
        const { dialog } = manager.electron;
        dialog.showSaveDialog({
            defaultPath,
            filters: [
                { name: 'Whiteboard', extensions: ['whiteboard'] },
            ],
        }, (filepath) => {
            if (!filepath) {
                return; // canceled
            }

            // Otherwise, create a new window opening this thing
            const data = {
                slide: [
                    { title: 'New Whiteboard Deck' },
                ],
            };
            saveToFile(filepath, data, () => {
                console.log('SAVED TO ', filepath);
                manager.createWindow(filepath, callback);
            });
        });
    },

    showAboutWindow(manager) {
        // TODO integrate full one into elmoed, this one is glitchy as hell
        const { dialog } = manager.electron;
        const title = 'About Whiteboard';
        const message = `
            Whiteboard v${packageJson.version}
        `.replace(/\s+/g, ' ').trim();
        const detail = `
            Whiteboard is free software, licensed under
            the ${packageJson.license} license.
            Built with Electron v${packageJson.devDependencies.electron}.
        `.replace(/\s+/g, ' ').trim();
        dialog.showMessageBox({
            title,
            detail,
            message,
            type: 'info',
            buttons: ['Ok'],
        });
    },
};
