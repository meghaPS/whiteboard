<riotlite />

<component name="editor">
    <oldshiny>
        <div id="{{ uuid }}">
        </div>
        <script>
            function create(props) {
                ace.editor.mount(uuid);
            }

            function destroy(props) {
                ace.editor.unmount(uuid);
            }

            // oldshiny also includes the following events
            function onbeforeparentupdated() {
                // essentially, stash away the element somewhere else
            }

            function onafterparentupdated() {
                // restore the element
            }

        </script>
    </oldshiny>
</component>


<component name="button">
    <for in="things">
        <h1>Hello {{item}}!</h1>
    </for>
    <if visible>
        <h1>Hello {{item}}!</h1>
    </if>
    <div class="red" name="" onclick="wasclicked">
        {{ content }}
    </div>

    <script>
        // 'use strict'; // no need, automatically included
        // BUILT IN LINTING :D
        function wasclicked(ev) {
            const {component} = ev.target;
            const {props} = component;
            literiot.rerender(component, props); // simply defer to built-in render
        }

        // ALL functions must be written as such:
        function render(props) {
            // props can be modified
            return literiot.render(props); // simply defer to built-in render
        }

        // NO CODE outside of functions
    </script>
</component>

<script>
    function outer_html(element, ns) {
        // Rewrites onclick to include full namespace as attached to window obj
        for (prop in element.getProps()) {
            const oldValue = element[prop];
            if (prop.startsWith('on')) {
                newValue = `l__${ns}__${oldValue}`;
                element[prop] = 'newValue;
                // Attach a reference to a parent component object to all
                // components with events
                element.component = props;
            }
        }

        return element;
    }

    function rerender(component, props) {
        const {firstDOMElement, lastDOMElement, rerenderPreHooks} = component;
        for (const rerenderPreHook of rerenderPreHooks) {
            rerenderPreHook();
        }
        component.props = props; // set new props
        new_html = render(props);

        for (const rerenderPostHook of rerenderPostHooks) {
            rerenderPostHook();
        }
        const siblings = firstDOMElement.parent.children();
        // TODO: Remove all siblings from DOM
        // Delete all DOM
    }

    function render(props) {
        // this is default render function
        const result = [];
        const ns = 'litegear__button';

        // When re-rendering, "component" gets set in props
        const component = props.component === null ? {props} : props.component;
        for (const child in props.children) {
            if (child.textNode === true) {
                result.push(render_template(child, props));
            } else if (child.tagName in components) {
                const childProps = get_props(child);
                result.push(components[child.tagName](childProps));
            } else {
                result.push(outer_html(child, ns));
            }
        }
        return result.join('');
    }

    window.l__if__render = function if__render(props) {
        let op === '=';
        let operand2 === true;
        if (props.isGreaterThan) {
            op = '>'; // etc
            operand2 = props.pop('isGreaterThan');
        }

        const operand1 = Object.keys(props)[0];
        if (rg.expression(operand1, op, operand2)) { // actually evaluate expression
            return literiot.render(props); // simply defer to built-in render
        } else {
            return '';
        }
    }

</script>


